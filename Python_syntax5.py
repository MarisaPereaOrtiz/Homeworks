# -*- coding: utf-8 -*-
"""Copy of Python Syntax 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kP0NZQwjApiaT2mq7Dt-YEJmeDxMUkXX
"""

__ = ""

"""# Conditionals and Loops: Controlling Your Code's Flow

## Thinking in Paradigms: Code Abstractions

One of the great things about computers is their relentless reliability and ability to follow instructions; step by step, they get the job done.
Writing each step individually, however, would be far too time-consuming. For example, take a look at this code, which computes and prints the mean of 3 numbers:

```python
data = [1, 2, 3]
mean = 0
current_idx = 0
next_value = data[current_idx]
mean += current_idx
current_idx = current_idx + 1
next_value = data[current_idx]
mean += current_idx
current_idx = current_idx + 1
next_value = data[current_idx]
mean += current_idx
mean = mean / len(data)
print(mean)
```

It's sympathetic, in a way, but a waste of time--we could do the job quicker on the back of a napkin!  Besides, it's error-prone to write.  To take advantage of computers as time-saving machines and decrease chances of errors, we must find ways to describe the pattern those steps should fall in.  In today's session, we'll describe some of the ways we can abstract away the tedieousness of the steps computers must take, learning to identify when we are
working in each of the 4 programming paradigms, and how to shift between them:

  - **"Imperitive / Procedural" Programming**: Describing each of the sequence of steps the computer must perform. abstracting away the computer's *state*.
  - **"Functional" Programming**: Describing the results the computer must achieve, abstracting away the computer's *transformations*.
  - **"Object-Oriented" Programming**: Describing the forms the computer must take, abstracting away the computer's *data*.
  - **"Declarative / Logical" Programming**: Describe the problem the computer must solve, abstracting away the computer's *context*.

  
Procedural Programming is often simplest, because the steps one writes is most similar to the steps the computer actually takes.  To see how it started and get a sense of how the other paradigms evolved, take a look at this code, which computes and prints the mean of 3 numbers:

### Demo: Printing the mean of a list of numbers
  
This can evolve from very specific instructions...

```python
data = [1, 2, 3]
mean = 0
idx = 0
**LINE 5**  # The name of this line (note: not valid python code, just for demonstration
value = data[idx]
mean += value
idx += 1
if idx < len(data):  # check if the index is still able to access elements of "data", which mean's it still has work to do
    **GOTO LINE 5**  # skip everything inside the "while" loop and continue on with the rest of the program.
mean /= len(data)
print(mean)
```

...to fairly specific instructions...


```python
data = [1, 2, 3]
mean = 0
idx = 0
while True:  # Repeat the indented block of code underneath forever
    value = data[idx]
    mean += value
    idx += 1
    if idx == len(data):  # check if the index is now past the last index of "data", which mean's it's reached the end of the line
        break  # skip everything inside the "while" loop and continue on with the rest of the program.
mean /= len(data)
print(mean)
```
        
...to even more general instructions...
```python
data = [1, 2, 3]
mean = 0
for value in data:  # repeach the block of code underneath "for each" elment of data, assigning the name "value" to that element
    mean += value
mean /= len(data)
print(mean)
```

...to even more more general instructions...
```python
data = [1, 2, 3]
mean = sum(data)
mean /= len(data)
```
    
...to, basically as general as you get instructions...
```python
data = [1, 2, 3]
mean = sum(data) / len(data)
print(mean)
```

...**which somehow get more specific again as we speak more abstractly.**..

```python
data = [1, 2, 3]
mean = lambda x: sum(data) / len(data)  # Defining a new function
print(mean(data))
```

...**and then gets almost philosophical in its abstraction.**
```python
my_data = Data([1, 2, 3])  # Only showing the usage here, not how it was created
print(my_data.mean())
```
  
Interesting, right?  Abstraction is quite nice, but it comes at a cost: when the computer tells you something's wrong, it's a bit harder to troubleshoot the problem's source, because there is so much code running "under the hood".  To make it easier to troubleshoot, then, we'll learn about Python's data model and how go up and down levels of abstraction in order to have a good mental model of how Python is doing things.

## Expressions vs Blocks

The second aspect of today's work will be to learn to avoid having the computer do "half" steps, whenever possible; in other words, to complete a task we value on every single line of code.  This ideal will drive the entire course, as we use more and more abstract tools to do more and more valuable work for us. 

For example, if we want to set three coordinates a value, we could do this:

```python
# set x, y, and z
x = 1  # set the x value
y = 2  # set the y value
z = 3  # set the z value
```

Or this:

```python
x, y, z = 1, 2, 3  # set x, y, and z
```

When we work this way, it becomes easer to describe our code to others and reason about it when we want to change it to do other things.  To start on that journey, we'll learn how to do each of the steps below as both a single line and as a block of code.

## "If" statements: Conditional Assignment

"If" statements let Python make choices: one choice if some value is **Truthy**, and another if the value is **Falsy**.  This is called **conditional** behavior.  
For example, **Conditional Assignment** has Python assigning a name to one value if something is true, and another if it is false:

```python
x = 30 if sum([1, 2, 3]) < 5 else 90   
print(x)  # 90
```
Note that Python requires that both the True and False values are specified here. 

Every Python data type has a **Falsy** value--the value that makes the  **bool()** function return False.  Here's the table of common ones:

| bool | int  | float | str | list | tuple | dict | set | None |
| :--: | :--: | :--: | :--: | :--: | :--: |  :--: | :--: | :--: |
| False | 0 | 0. | "" | [] | () | {} | {} | None |

Basically, if the value is **0**, **Empty**, **False**, or **None**, it's automatically considered Falsy. If not, it's True!  This lets us write code like this:

```python
data = [1, 2, 3]
result = 'I have data!' if data else 'My list is empty. :-('
```

```python
data = None
result = 'I have data!' if data else 'No data today. :-('
```

**Exercises**: Write out Python's conditional assignment code that represents each sentence.  If there is a blank line, replace it with code.

1. "old_enough_to_drink" is True if your_age is greater than the legal drinking age, otherwise it's False.
"""

your_age = 15
legal_drinking_age = 18
old_enough_to_drink = 'yes' if your_age >= legal_drinking_age else 'no'
old_enough_to_drink

"""2. Do you have enough data yet?  "Yes" if if there are more than 10 values in the collection, and "No" if not."""

data = [32, 6, 8, 4, 45, 6, 7, 34, 2]
enough_data = True if len(data) > 10 else False
enough_data

"""3. If the third value in the list of lottery numbers is equal to the 2nd value, you get a "win" result.  If not, you "lose"."""

lottery = [3, 5, 5, 9, 12]
result = 'win' if lottery[1] == lottery[2] else 'lose'
result

"""4. If the 1st value in the list is greater than the last value, then x should be set to 3.  If not, it's should be set to 2."""

values = [1, 2, 3, 4][::-1]
x = 3 if values[0] > values[-1] else 2
x

"""5. If data is None, then result should be None.  If it's anything else, then it should be "published!""""

data = None
result = 'published' if data else None
result

"""**Exercises in Truthyness, part 2**

For each of these statements, predict the value Python will return

```python
True if [1, 2, 3] else False #True
```
"""

True if [1, 2, 3] else False

"""```python
False if [] else True #True
```
"""

False if [] else True

"""```python
True if False else False
```
"""

True if False else False #False

"""```python
False if 3 - 3 else True # True
```
"""

False if 3 - 3 else True # True

"""```python
True if -1 else False #True
```
"""

True if -1 else False #True

"""```python
True if [False] else False # True
```
"""

True if [False] else False # True

"""```python
True if "False" else False # False
```
"""

True if "False" else False # string

"""```python
True if [True, False, None][0] else False #True
```
"""

True if [True, False, None][0] else False #True

"""```python
False if [True, [False, 1], None, 0][:-1][::-1][0] else True #True
```
"""

False if [True, [False, 1], None, 0][:-1][::-1][0] else True #True

"""### "If" Blocks

We can also write Python in blocks of code using **if** statements, a process called **"Flow Control"**.  Here are some examples:

```python
if sum([1, 2, 3]) < 5:
    x = 30
print(x)  # NameError: 'x' is underfined!
```

Here are two other ways it could be written:

```python
if sum([1, 2, 3]) < 5:
    x = 30
else:
    x = 90
```
    
```python
x = 90
if sum([1, 2, 3]) < 5:
    x = 30
```

Which do you prefer?

The great part about blocks, though, is that they are very flexible.  They can have as many lines inside them as you want, and they allow for multiple conditions via **elif**:

```python
if sum([1, 2, 3]) < 5:
    x = 30
elif sum([1, 2, 3]) < 7:
    x = 50
else:
    x = 90
```

You can use as many "elif"s as you want between the "if" and "else" sections.  If you use another if statement when you meant "elif", though, Python will think that you started a second "if" block.  For example, Python thinks that this is 2 blocks of code.:

```python
if sum([1, 2, 3]) < 5:
    x = 30
if sum([1, 2, 3]) < 7:
    x = 50
else:
    x = 90
```

#### Aside: "Meaningful Whitespace"

The main thing to know about code blocks in Python is that, unlike other languages, Python defines the end of a block by where it *stops indenting*.  This is called having **"meaningful whitespace"**.  Every line in Python should be indented the same way, with the same number of spaces in each section, so that Python knows they belong together.  If Python can't figure out where a block starts or ends, you will see an **IndentationError**.

**Exercises**: Let's do the previous exercises again, this time with blocks.  *Please don't copy-paste, though* Getting used to typing the instructions will help you get more comfortable with the language's syntax.  Before long, you'll find it quicker to type out the code!

1. "old_enough_to_drink" is True if your_age is greater than the legal drinking age, otherwise it's False.
"""

your_age = 10
legal_drinking_age = 18
if your_age > legal_drinking_age:
  old_enough_to_drink = True
else: 
  old_enough_to_drink = False
old_enough_to_drink

"""2. Do you have enough data yet?  Print "Yes" if if there are more than 10 values in the collection, and "No" if not."""

data = [1, 2, 3, 4, 5, 6, 7 ,8 , 9, 1, 2]
if len(data) > 10:
  enough_data = 'Yes'
else:
  enough_data = 'No'
enough_data

"""3. If the third value in the list of lottery numbers is equal to the 2nd value, print get a "win" result.  If not, print "lose"."""

lottery = [1, 2, 3, 4, 12, 10]
if lottery[1] == lottery[2]:
  print('win')
else:
  print('lose')

"""4. If the 1st value in the list is greater than the last value, then x should be set to 3.  If not, it's should be set to 2."""

list1 = [1, 2, 3, 4, 5]
if list1[0] > list1[-1]:
  x = 3
else:
  x = 2
x

"""5. If data is None, then print the statement "Go collect data".  result should be None.  If it's anything else, then calculate its mean and print the string "published!""""

data = [1, 2, 3]
if data == None:
  print('Go collect data')
else:
  mean = sum(data) / len(data)
  print(mean)
  print('published!')

"""## Assertions: Checking Your Logic

As our code gets longer, we need to hold more of it in our head to keep track of how we expect our data to change along the way.   If we want, we can **assert** to Python that we believe something is True in order to double-check our logic.  This way, if we're mistaken, Python can raise an **AssertionError** for us so that we know earlier when soething went wrong.  If we're correct, then Python just ignores it and carries on.  

Here are some examples so you can see how that works:
"""

assert sum([1, 2, 3]) > 0, "The data is supposed to have a positive sum here."

assert sum([-10, 2, 3]) > 0, "The data is supposed to have a positive sum here."

data = None
assert data, "We can't work without data!"

"""## Loops: "Don't Repeat Yourself"

### "While" Loops

**While** loops run a block of code for as long as the header returns True.  If it's false, then it skips the block of code and continues onward.

For example, this code will run forever, because "True" is always truthy:
```python
while True:
    print("Hi, everybody!")
    print("I am alive!")
print("I'm done.")  # This will never be run.
```

You can "break out" of any loop, even an endless one, by using the **break** statement.  If Python sees it, it immediately skips the rest of the block and continues on:

```python
while True:
    print("Hi, everybody!")  # This will run
    break
    print("I am alive!")  # This won't.
print("I'm done.")  # this will be run.
```


If we want, we can use while loops to perform an operation a certain number of times, and use an "if statement" to make the break appear.  For example:

```python
x = 0
while True:
    x += 1
    print(x)
    if x > 5:
        break
print("I'm done.")
```

We can see here that code blocks can be nested!  That's exciting, right?  

Notice that "x" is set before the loop.  That's called **preallocating** the variable, and it's often needed before doing some kind of automation on it.  In a sense, this code is doing three things, each in different blocks: 

  1. Getting Data
  2. Modifying Data
  3. Making a Decision, based on Data
  
Well, let's try it out!

**Exercises**: Write a while loop that does each of the following tasks:

1. Print "Hello, Name" before for each name in the list of names
"""

names = ["Johnny", "Carol", "June", "Susanne"]
x = 0
while True:
  print('Hello,', names[x])
  x += 1
  if x >= len(names):
    break
print('I\'am done')

"""2. Print the number of letters are in each name"""

names = ["Johnny", "Carol", "June", "Susanne"]
x = 0
while True:
  print(len(names[x]))
  x += 1
  if x == len(names):
    break
print('done')

"""3.Make a Dictionary showing how many letters are in each name"""

names = ["Johnny", "Carol", "June", "Susanne"]
name_lengths = {}  # to add a key to this dictionary, follow this example: name_length['Johnny'] = 3

names = ["Johnny", "Carol", "June", "Susanne"]
x = 0
name_lengths = {}

while True:
    name_lengths[names[x]] = len(names[x])
    x += 1
    if x >= len(names):
        break
print(name_lengths)

"""4. print "Hello, World!" 5 times."""

x = 0
while True:
  x += 1
  print('Hello, World') 
  if x == 5:
    break

"""5. print "Hello World!" for each name in the list, but only if the first letter of the name begins with a "J"."""

names = ["Johnny", "Carol", "June", "Susanne"]
x = 0

while True:
    if names[x][0] == 'J':
        print('Hello, World')
    x += 1
    if x == len(names):
        break
print('done')



"""## Iteration: "For" Loops

Although while-loops are used a lot in "lower-level" programming languages, they don't show up very much in Python, R, Matlab, Javascript, Go, or, well, a lot of others.  That's because they can be difficult to reason about; the reader has to look at the whole loop and keep all the steps in their head to be sure they understand the behavior and purpose of the loop itself.

That's what "For-each" loops (in Python, just called "For" loops) are meant to help with.  In a "For-each" loop, you specify how many times the loop will occur before starting the loop, and even set the variable names you'll be using in the header.  This makes a big difference in readability!  Let's take a look:

```python
data = [0, 1, 2]
for value in data:
    print(value * 2)
```

A lot of work is happening here in the for-loop.  When unpacked, this is what Python is doing;

```python
data = [0, 1, 2]
collection = iter(data)  # Create an "iterator" out of data, which gives the "next" value each time the next() function is called on it.

value = next(collection)
print(value * 2)

value = next(collection)
print(value * 2)

value = next(collection)
print(value * 2)
```

**Iterators** and **Iterables (types that can become an Iterator)** are super useful for for-loops, and there are many Python functions that make them for you.  The most important one is the **range()** function, which produces integers between two values.  For example:

```python
numbers_0_through_5 = range(5)
for number in numbers_0_through_5:
    print(number)
```

No need to write the list yourself!
    

We'll do more with for-loops later.  For now, let's simplify those "while loop" exercises from before:

**Exercises**: Write a for loop that does each of the following tasks:

1. Print "Hello, Name" before for each name in the list of names
"""

names = ["Johnny", "Carol", "June", "Susanne"]

for x in names:
  print('Hello,', x)

"""2. Print the number of letters are in each name"""

for x in names:
  print(len(x))

"""3.Make a Dictionary showing how many letters are in each name"""

names = ["Johnny", "Carol", "June", "Susanne"]
name_lengths = {}  # to add a key to this dictionary, follow this example: name_length['Johnny'] = 3

names = ["Johnny", "Carol", "June", "Susanne"]
name_lengths = {}
for x in names:
    name_lengths[x] = len(x)
print(name_lengths)

"""4. print "Hello, World!" 5 times."""

for x in range(5):
  print('Hello, World!')

"""5. print "Hello World!" for each name in the list, but only if the first letter of the name begins with a "J"."""

names = ["Johnny", "Carol", "June", "Susanne"]
for x in names:
  if x[0] == 'J':
    print('Hello World!')

"""### Mapping Collections: Transforming Each Element of a Collection

Often, you want to do something to the data inside your collection--double it, increase it, compute some metric, etc.  
At the end, you still have the same *number* of elements, but the values themselves have changed.  
We will be looking at lots of ways to accomplish this in  Python, but first we're going to use a **for-loop** in a format called a **comprehension**.

Comprehensions produce a new collection containing new values *"for each"* value *in* the original collection.  They look like this:

```python
>>> data = [1, 2, 3]
>>> list(x * 2 for x in data)
[1, 4, 9]
```

The code above does the same as the following:
```python
>>> data = [1, 2, 3]
>>> [data[0] * 2, data[1] * 2, data[2] * 2]
[1, 4, 9]
```

Another example:

```python
>>> data = [1, 2, 3]
>>> tuple(math.sqrt(value) + 2 for value in data)
(3.0, 3.414, 3.732)
```

```python
>>> data = [1, 2, 3]
>>> (math.sqrt(data[0]) + 2, math.sqrt(data[1]) + 2, math.sqrt(data[2]) + 2)
(3.0, 3.414, 3.732)
```

Notice that the variable **x** and **value** are created without using the assignment operator! You can name this anything you want, and it is created anew for each individual element of the collection.

For lists, Python has a shortcut (called a **list comprehension**):

```python
>>> data = [1, 2, 3]
>>> [x * 2 for x in data]
[1, 4, 9]
```

There is also one for dict (**"dict comprehensions"**), but not for any other type.  See below:

```python
>>> data = [1, 2, 3]
>>> {x: x * 2 for x in data}
{1: 1, 2: 4, 3: 9}
```

**Exercises**: Transform each value in the given collection into the requested collection type using the requested transformation

Example: A tuple of each value in "data", with each value increased by 3
```python
>>> data = [10, 20, 30]
>>> tuple(x + 3 for x in data)
(13, 23, 33)
```

1. Make a list that adds 1 to each value in "data":
"""

data = [1, 2, 3]
[x+1 for x in data]

"""2. Make a tuple that calculates the absolute value of each element in "data", using the built-in abs() function:"""

data = (-2, -1, 0, 1, 2)
tuple(abs(x) for x in data)

"""2b. Make a list of the cosines of each value in "data":"""

import math
data = (-2, -1, 0, 1, 2, 3)
[math.cos(x) for x in data]

"""2c. Round all these numbers to the nearest integer (use the "round()" function):"""

data = [1.2, 1.5, 0.7, -2.1]
[round(x) for x in data]

"""3. Make a list of all the first letters of each name in the list:"""

data = ["John", "Harry", "Moe", "Luke"]
[x[0] for x in data]

"""4. Make a tuple of the lengths of each name:"""

data = ["John", "Harry", "Moe", "Luke"]
tuple(len(x) for x in data)

"""5. Make a dictionary that maps all the words in the list to their length:"""

data = ["John", "Harry", "Moe", "Luke"]
{x : len(x) for x in data}

"""6. Make a set of all the word lengths in the tuple:"""

data = ("John", "Harry", "Moe", "Luke")
set(len(x) for x in data)

"""### Filtering Collections

What if you only want to include *some* values in a collection?  With the **if** statement and a **logical expression**, you can do it in a comprehension!  For example:

```python
>>> data = [1, 2, 3, 4]
>>> [x for x in data if x > 2]
[3, 4]
```

This can be combined with various transformations as well!

```python
>>> data = ["John", "Harry", "Moe", "Luke"]
>>> [x[0] for x in data if len(x) < 5]
["J", "M", "L"]
```

**Exercises**:

Get All positive values in the following list:
"""

data = [-6, 3, -1, 10, -5, 0]
[x for x in data if x >= 0]

"""Make a tuple of all names that start with the letter "L":"""

data = ("John", "Harry", "Moe", "Luke")
tuple(x for x in data if x[0] == 'L')

"""Make a list of all names that have more than 3 letters in the name:"""

data = ("John", "Harry", "Moe", "Luke")
[x for x in data if len(x) > 3]

"""Make a list of the last letter of all names that have more than 3 letters in the name:"""

data = ("John", "Harry", "Moe", "Luke")
[x[-1] for x in data if len(x) > 3]

"""Make a list of all values who have positive cosines:"""

import math
data = [1, 2, 3, 4, 5, 6, 7]
[x for x in data if math.cos(x) >= 0]

"""Make a dictionary, mapping each name to its length, but only if the sine of its length is positive:"""

import math
data = ["John", "Harry", "Moe", "Luke"]
{x : len(x) for x in data if math.sin(len(x)) >= 0}

"""### Combining Them: Filtering, Transforming, and Aggregating

Okay, let's combine everything together into a single step!  To get the minimum value of the squares of all values less than 0 in the following list:

```python
>>> data = [-5, -3, 1, 2, 3]
>>> min(x ** 2 for x in data if x < 0)
9
```

Let's try it out!

**Exercises**:

The sum of all squares for all values in the dataset [1, 7, 3, 4, 9] greater than 4.
"""

data = [1, 7, 3, 4, 9]
sum(x**2 for x in data if x > 4)

"""The minimum length of all names in the list who has at least 4 unique letters in their name: ["Bobby", "Cindy", "Anna", "Joshua", "Alan", "Hannah", "Jeffrey"]"""

data = ['Bobby', 'Cindy', 'Anna', 'Joshua', 'Alan', 'Hannah', 'Jeffrey']
min(len(x) for x in data if len(set(x.lower())) >= 4)

"""The total length of all the names in the list that starts with an "R": ["Joey", "Monica", "Chandler", "Rachel", "Ross", "Phoebe"]"""

data = ['Joey', 'Monica', 'chandler', 'Rachel', 'Ross', 'Phoebe']
sum(len(x) for x in data if x[0] == 'R')

"""## Asside: Chaining Them: Repeatedly Filtering and Transforming before Aggregating
Often, data analysis pipelines require multiple repeated transforms and filters before the analysis is complete.  This can get quite unwieldy, to say the least.  For example:
"""

tuple(x for x in (x ** 2 for x in (len(x) for x in (x for x in ["Joey", "Monica", "Chandler", "Rachel", "Ross", "Phoebe"]) if x[0] == 'R') if x < 10) if x < 36)

"""You could split this into multiple lines, but it doesn't always help keep it readable.  For example:"""

tuple \
(x for x in 
(x ** 2 for x in 
(len(x) for x in
(x for x in 
["Joey", "Monica", "Chandler", "Rachel", "Ross", "Phoebe"])
if x[0] == 'R')
if x < 10) 
if x < 36)

"""Often, people will just make a loop when they are in the situation, but this, too can get out of hand:"""

friends = ["Joey", "Monica", "Chandler", "Rachel", "Ross", "Phoebe"]
result = ()
for friend in friends:
    if friend[0] == 'R':
        friend_len = len(friend)
        if friend_len < 10:
            friend_len_squared = friend_len ** 2
            if friend_len_squared < 36:
                result = result + (friend_len_squared,)
result

"""A simpler way is to just split it into multiple steps:"""

friends = ["Joey", "Monica", "Chandler", "Rachel", "Ross", "Phoebe"]
friends = [len(x) for x in friends if x[0] == 'R']
friends = [x ** 2 for x in friends if x < 10]
tuple(x for x in friends if x < 36)

"""This is a little better, but it can be a lot more readable still. We will be looking at many ways to make it easier for us to transform and filter data in later units.

## Review: Class Discussion

  1. Python has a lot of symbols in its syntax.  What are they, and what are they used for?
  2. What are functions?  How do you use them?  Where can you get them?
  3. What kinds of data collections are built-in to Python?  What concepts do they represent?
  4. What is a "logical expression"?  What is a "state change"?
  5. What is the "for...in" statement about?  How do you use it?
  6. What is the "if" statement about?  How do you use it?
  7. Would you like a coffee break?
"""